<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Snake — The Yeasir</title>
<style>
:root{
  --bg1:#0b1020; --bg2:#0f1b3a;
  --card:rgba(255,255,255,.08);
  --text:#eaf0ff; --muted:rgba(234,240,255,.7);
  --btn:rgba(255,255,255,.12);
  --btn2:rgba(255,255,255,.18);
}
*{box-sizing:border-box}
body{
  margin:0; min-height:100vh;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
  color:var(--text);
  background: radial-gradient(1200px 800px at 20% 10%, #1f2a60 0%, transparent 60%),
              radial-gradient(1000px 700px at 80% 20%, #3b1d5a 0%, transparent 55%),
              linear-gradient(180deg, var(--bg1), var(--bg2));
  display:flex; align-items:center; justify-content:center;
  padding:14px;
}
.wrap{width:min(560px,100%); display:flex; flex-direction:column; gap:12px;}
.topbar{
  display:flex; justify-content:space-between; align-items:center; gap:10px;
  padding:12px; background:var(--card);
  border:1px solid rgba(255,255,255,.14);
  border-radius:16px; backdrop-filter: blur(10px);
}
.left{
  display:flex; flex-direction:column; gap:2px;
}
.left b{font-size:14px}
.left span{font-size:12px; color:var(--muted)}
.right{
  display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;
  font-size:12px; color:var(--muted);
}
.pill{
  padding:7px 10px; background:rgba(0,0,0,.18);
  border:1px solid rgba(255,255,255,.12);
  border-radius:999px; color:var(--text);
}
.btns{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end}
button{
  border:0; color:var(--text); background:var(--btn);
  border:1px solid rgba(255,255,255,.14);
  padding:10px 12px; border-radius:12px; font-weight:700;
  cursor:pointer; touch-action:manipulation;
}
button:active{transform:scale(.98); background:var(--btn2)}
canvas{
  width:100%;
  aspect-ratio:1/1;
  background:rgba(0,0,0,.22);
  border:1px solid rgba(255,255,255,.14);
  border-radius:18px;
  display:block;
  touch-action:none;
}
.footer{
  text-align:center; font-size:12px; color:var(--muted);
}
</style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div class="left">
      <b>Snake — The Yeasir</b>
      <span>Swipe to move • Slower speed • Realistic body</span>
    </div>
    <div class="right">
      <span class="pill">Score: <b id="score">0</b></span>
      <span class="pill">Best: <b id="best">0</b></span>
      <div class="btns">
        <button id="startBtn">Start</button>
        <button id="restartBtn">Restart</button>
        <button id="pauseBtn">Pause</button>
        <button id="fsBtn">Fullscreen</button>
      </div>
    </div>
  </div>

  <canvas id="game" width="600" height="600"></canvas>
  <div class="footer">সাপ হয়ে চুদবো তোমায়</div>
</div>

<script>
(() => {
  // Use your repo files
  const HEAD_IMG_URL = "./head.png";
  const FOOD_IMG_URL = "./food.png";

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const scoreEl = document.getElementById("score");
  const bestEl  = document.getElementById("best");

  const startBtn   = document.getElementById("startBtn");
  const restartBtn = document.getElementById("restartBtn");
  const pauseBtn   = document.getElementById("pauseBtn");
  const fsBtn      = document.getElementById("fsBtn");

  // Slower speed (you asked “a bit less”)
  // Old was ~120ms. Now 170ms = noticeably slower but still playable.
  let TICK_MS = 200;

  const GRID = 18;
  const PAD = 10;

  // HiDPI scaling
  function resizeCanvasToCSS(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(rect.width  * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resizeCanvasToCSS);
  resizeCanvasToCSS();

  function cellSize(){
    const rect = canvas.getBoundingClientRect();
    const usable = Math.min(rect.width, rect.height) - PAD*2;
    return Math.floor(usable / GRID);
  }

  const bestKey = "snake_best_v2";
  let best = Number(localStorage.getItem(bestKey) || 0);
  bestEl.textContent = best;

  const headImg = new Image();
  headImg.src = HEAD_IMG_URL;

  const foodImg = new Image();
  foodImg.src = FOOD_IMG_URL;

  let snake, dir, nextDir, food, score, running, paused, timer;

  function reset(){
    const mid = Math.floor(GRID/2);
    snake = [{x: mid, y: mid}, {x: mid-1, y: mid}, {x: mid-2, y: mid}];
    dir = {x:1,y:0};
    nextDir = {x:1,y:0};
    score = 0;
    running = false;
    paused = false;
    scoreEl.textContent = score;
    placeFood();
    draw();
  }

  function placeFood(){
    let p;
    do{
      p = {x: rand(0,GRID-1), y: rand(0,GRID-1)};
    }while(snake.some(s => s.x===p.x && s.y===p.y));
    food = p;
  }

  function rand(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

  function setDir(nd){
    // no direct reverse
    if (nd.x === -dir.x && nd.y === -dir.y) return;
    nextDir = nd;
  }

  function gameOver(){
    running = false;
    paused = false;
    if (timer) clearInterval(timer);

    if (score > best){
      best = score;
      localStorage.setItem(bestKey, String(best));
      bestEl.textContent = best;
    }

    alert(`Yeasir khaise ${score} bar Nahid reh`);
  }

  function step(){
    if (!running || paused) return;

    dir = {...nextDir};
    const head = snake[0];
    const newHead = {x: head.x + dir.x, y: head.y + dir.y};

    // walls
    if (newHead.x < 0 || newHead.x >= GRID || newHead.y < 0 || newHead.y >= GRID){
      gameOver(); return;
    }
    // self
    if (snake.some((s,i)=> i!==0 && s.x===newHead.x && s.y===newHead.y)){
      gameOver(); return;
    }

    snake.unshift(newHead);

    if (newHead.x === food.x && newHead.y === food.y){
      score++;
      scoreEl.textContent = score;
      navigator.vibrate?.(50);
      placeFood();
    } else {
      snake.pop();
    }

    draw();
  }

  function cellToPx(c, cs){
    return {x: PAD + c.x * cs, y: PAD + c.y * cs};
  }

  function drawGrid(cs){
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,rect.width,rect.height);

    ctx.globalAlpha = 0.15;
    for(let i=0;i<=GRID;i++){
      const x = PAD + i*cs;
      const y = PAD + i*cs;

      ctx.beginPath();
      ctx.moveTo(x, PAD);
      ctx.lineTo(x, PAD + GRID*cs);
      ctx.strokeStyle = "#ffffff";
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(PAD, y);
      ctx.lineTo(PAD + GRID*cs, y);
      ctx.strokeStyle = "#ffffff";
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  // Realistic body: rounded segments + subtle highlight + tail taper
  function drawBodySegment(px, cs, index){
    const inset = Math.max(3, Math.floor(cs*0.14));
    const w = cs - inset*2;
    const h = cs - inset*2;

    // Taper tail a bit
    const t = Math.max(0.72, 1 - index*0.012);
    const ww = Math.floor(w * t);
    const hh = Math.floor(h * t);
    const xx = px.x + inset + Math.floor((w-ww)/2);
    const yy = px.y + inset + Math.floor((h-hh)/2);
    const r  = Math.floor(Math.min(ww,hh)*0.38);

    // Main body
    roundRect(xx, yy, ww, hh, r);
    ctx.fillStyle = "rgba(220, 255, 230, 0.22)";
    ctx.fill();

    // Inner darker core
    roundRect(xx+2, yy+2, Math.max(0,ww-4), Math.max(0,hh-4), Math.max(0,r-2));
    ctx.fillStyle = "rgba(80, 200, 140, 0.22)";
    ctx.fill();

    // Highlight line
    ctx.globalAlpha = 0.35;
    ctx.beginPath();
    ctx.moveTo(xx + ww*0.2, yy + hh*0.35);
    ctx.lineTo(xx + ww*0.8, yy + hh*0.35);
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  function drawHead(px, cs){
    // Square-crop image on head cell (as requested)
    if (headImg.complete && headImg.naturalWidth > 0){
      // rotate head according to direction
      const cx = px.x + cs/2;
      const cy = px.y + cs/2;

      let ang = 0;
      if (dir.x === 1) ang = 0;
      else if (dir.x === -1) ang = Math.PI;
      else if (dir.y === 1) ang = Math.PI/2;
      else if (dir.y === -1) ang = -Math.PI/2;

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(ang);
      ctx.drawImage(headImg, -cs/2, -cs/2, cs, cs);
      ctx.restore();

      // Add small cartoon eyes on top (makes it feel alive)
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(ang);
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.beginPath(); ctx.arc(-cs*0.18, -cs*0.12, cs*0.06, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(-cs*0.18,  cs*0.12, cs*0.06, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.beginPath(); ctx.arc(-cs*0.19, -cs*0.12, cs*0.03, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(-cs*0.19,  cs*0.12, cs*0.03, 0, Math.PI*2); ctx.fill();
      ctx.restore();

    } else {
      // fallback
      roundRect(px.x+2, px.y+2, cs-4, cs-4, 12);
      ctx.fillStyle = "rgba(255,255,255,0.8)";
      ctx.fill();
    }
  }

  function drawFood(px, cs){
    if (foodImg.complete && foodImg.naturalWidth > 0){
      ctx.drawImage(foodImg, px.x, px.y, cs, cs);
    } else {
      ctx.fillStyle = "rgba(125,211,252,0.9)";
      ctx.beginPath();
      ctx.arc(px.x+cs/2, px.y+cs/2, cs*0.3, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function draw(){
    const cs = cellSize();
    drawGrid(cs);

    // Food
    const fpx = cellToPx(food, cs);
    drawFood(fpx, cs);

    // Body first, then head on top
    for (let i = snake.length - 1; i >= 0; i--){
      const s = snake[i];
      const px = cellToPx(s, cs);

      if (i === 0) {
        drawHead(px, cs);
      } else {
        drawBodySegment(px, cs, i);
      }
    }

    // Start hint
    if (!running){
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      roundRect(PAD+10, PAD+10, GRID*cs-20, 62, 14);
      ctx.fill();
      ctx.fillStyle = "#eaf0ff";
      ctx.font = "700 16px system-ui";
      ctx.fillText("Tap Start • Swipe to move", PAD+24, PAD+40);
      ctx.fillStyle = "rgba(234,240,255,.75)";
      ctx.font = "12px system-ui";
      ctx.fillText("Head: your pic • Food: your pic", PAD+24, PAD+58);
    }

    // Paused hint
    if (paused){
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      roundRect(PAD+10, PAD+10, GRID*cs-20, 52, 14);
      ctx.fill();
      ctx.fillStyle = "#eaf0ff";
      ctx.font = "800 18px system-ui";
      ctx.fillText("Paused", PAD+24, PAD+44);
    }
  }

  function start(){
    if (running) return;
    running = true;
    paused = false;
    if (timer) clearInterval(timer);
    timer = setInterval(step, TICK_MS);
    draw();
  }

  function restart(){
    if (timer) clearInterval(timer);
    reset();
    start();
  }

  function togglePause(){
    if (!running) return;
    paused = !paused;
    draw();
  }

  // Buttons
  startBtn.addEventListener("click", start);
  restartBtn.addEventListener("click", restart);
  pauseBtn.addEventListener("click", togglePause);

  fsBtn.addEventListener("click", async () => {
    try{
      const el = document.documentElement;
      if (!document.fullscreenElement) await el.requestFullscreen();
      else await document.exitFullscreen();
    }catch(e){}
  });

  // Swipe controls
  let touchStart = null;
  canvas.addEventListener("touchstart", (e)=>{
    const t = e.touches?.[0];
    if (!t) return;
    touchStart = {x:t.clientX, y:t.clientY};
  }, {passive:true});

  canvas.addEventListener("touchend", (e)=>{
    const t = e.changedTouches?.[0];
    if (!t || !touchStart) return;
    const dx = t.clientX - touchStart.x;
    const dy = t.clientY - touchStart.y;
    touchStart = null;

    if (!running) start();

    const ax = Math.abs(dx), ay = Math.abs(dy);
    if (Math.max(ax,ay) < 16) return;

    if (ax > ay){
      setDir({x: dx>0 ? 1 : -1, y:0});
    } else {
      setDir({x:0, y: dy>0 ? 1 : -1});
    }
  }, {passive:true});

  // Also allow arrow-key control for desktop
  window.addEventListener("keydown", (e)=>{
    if (e.key === "ArrowUp") setDir({x:0,y:-1});
    if (e.key === "ArrowDown") setDir({x:0,y:1});
    if (e.key === "ArrowLeft") setDir({x:-1,y:0});
    if (e.key === "ArrowRight") setDir({x:1,y:0});
  });

  reset();
})();
</script>
</body>
</html>
